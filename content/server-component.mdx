---
title: 'React Server Components: Server-Side React for Better Performance'
excerpt: 'Discover React Server Components, an upcoming feature in React that enables server-side rendering of components.'
publishedAt: '2024-07-02T10:00:00.000Z'
image: '/assets/blog/rendering/rsc.webp'
author:
  name: Hamza Miloud amar
  picture: '/me.jpg'
tags: ['Rendering Pattern', 'React', 'Server Components']
---

We think this conversational style might be a bit more fun and easier to follow than a regular article. Hopefully, it makes learning about these rendering patterns less boring and more hands-on!

<Conversation>

<Conversation.Thread from="user">
  Hey Chat, could you explain Server Components in simple terms,
  assuming I have no idea about **rendering patterns**? ü§î
</Conversation.Thread>

<Conversation.Thread from="narrator">
  <div>
    Think of a web app like a restaurant. The server, like the chef,
    cooks up all the website's parts in the kitchen. Some components
    are like a burger ‚Äì ready to eat right away (server component).
    Others are like a steak ‚Äì they need a little extra something, like
    a sprinkle of salt or a drizzle of sauce, added by the waiter
    (client component) at the table for a better experience.
  </div>
</Conversation.Thread>

<Conversation.Thread from="user">
  Hmm, I think I get the general idea, but could you explain how this
  relates to websites?
</Conversation.Thread>

<Conversation.Thread from="server">
  <div>
    As a server, my primary function is to generate the initial HTML
    structure of a web page. However, this process involves two
    distinct component types: server components and client components
  </div>
  <div>
    **Server components:** I render these entirely on the server,
    generating their HTML output. No JavaScript code is sent to the
    client, eliminating the need for hydration.
  </div>
  <div>
    **Client components:** on the other hand, are rendered by me but
    also include JavaScript code that is sent to the browser (for
    application state, event handlers, and access to DOM nodes). This
    allows the browser to "hydrate" these components, enabling
    interactive features and dynamic updates within the web page.
  </div>
</Conversation.Thread>

<Conversation.Thread from="browser">
  Thanks for explaining, server! My role as the browser becomes more
  streamlined. I receive the generated HTML from the server and
  display it to the user. Since the heavy lifting is done server
  component, I have less JavaScript to parse and execute, leading to
  faster Time to interact (TTI).
</Conversation.Thread>

<Conversation.Thread from="user">
  Thanks. Client components make sense now as they're what we use in
  SSR, a component that render on the server and hydrate on the
  client. Could you give me some examples of server components to help
  clarify things?
</Conversation.Thread>

<Conversation.Thread from="server">
  <div>
    Okay, let's simplify it: Server Components run exclusively on the
    server. Let me give you an example to illustrate this...
  </div>
  <div>
    Let's take a component that displays the date in the format
    (YYYY.MM.DD). With traditional client components, we'd send the
    raw date and JavaScript code to the browser for formatting. Server
    components, however, allow us to format the date directly on the
    server and send only the formatted result in HTML, simplifying the
    process and reducing client-side load.
  </div>
</Conversation.Thread>

<Conversation.Thread from="user">
  What are the main benefits of using Server Components?
</Conversation.Thread>
<Conversation.Thread from="server">

  <div> **Optimize Data Fetching:** Fetch data within Server Components to keep the data-fetching logic close to where it's used.</div>
  <div>
    **Improved Performance:** Fetching and caching data within server
    components can significantly improve performance by reducing
    client-side load and optimizing response times.
  </div>
  <div>
    **SEO-Friendly:** Server-rendered HTML is more easily indexed by
    search engines, improving SEO.
  </div>
  <div>
    **Improved User experience:** Since server components don‚Äôt
    re-render on the client, the client's processing load is reduced, improving the application Time To Interact(TTI).
  </div>
  <div>
    **Simplified Codebase:** Server Components can handle data
    fetching directly, simplifying the data handling logic and
    reducing the need for complex client-side state management.
  </div>
  <div>
    **Improved Security:** Server components enhance security by
    keeping sensitive data out of reach from the client.
  </div>
</Conversation.Thread>
<Conversation.Thread from="user">
  What are the cons of using Server Components?
</Conversation.Thread>
<Conversation.Thread from="server">
  <div>
    **New paradigm**: Introducing a new approach that requires a
    learning curve.
  </div>
  <div>
    **Limited Adoption**: Not all packages are currently compatible
    with Server Components. This new paradigm requires further
    integration across the ecosystem.
  </div>
</Conversation.Thread>

<Conversation.Thread from="user">
  When should you opt for a client component instead of a server
  component?
</Conversation.Thread>
<Conversation.Thread from="server">
  <div>
    In general, you should aim to use Server Components whenever
    possible. They reduce the JavaScript bundle size, improve
    performance, and simplify data fetching. However, there are
    specific scenarios where Client Components become necessary:
  </div>
  <div>
    **Managing State**: If your component needs to maintain and update
    its own internal state, a Client Component is required.
  </div>
  <div>
    **Leveraging Effects**: To perform side effects like fetching data
    after a component has mounted, or subscribing to external events,
    you'll need a Client Component. Server Components don't have a
    lifecycle for these operations.
  </div>
  <div>
    **Interacting with Browser APIs**: When your component needs to
    interact directly with browser APIs (e.g., accessing geolocation,
    or working with local storage), a Client Component is . These APIs
    aren't available on the server.
  </div>
  <div>
    **manipulating the DOM**: If your component needs to directly
    interact with the DOM (e.g., for focusing an input, measuring
    dimensions, applying animations, or handling click events), you'll
    need to use a Client Component. Server Components don't have
    access to the browser's DOM.
  </div>
</Conversation.Thread>

<Conversation.Thread from="user">
  I'm really liking this Server Component Pattern! I'm curious,
  though, are there any potential performance issues I should be aware
  of?
</Conversation.Thread>

<Conversation.Thread from="user">
  <div>
    That makes sense. So, what can I do to prevent this performance
    issues?
  </div>
</Conversation.Thread>

<Conversation.Thread from="server">
  <div>
    Certainly! There are several effective strategies for optimizing
    the performance of Server Components.
  </div>
  <div>
    To enhance site size performance, we can implement techniques
    outlined in this guide: [Static Site
    Enhancement.](/blogs/static-website#static-site-enhancement)
  </div>
  <div>
    For the issue of slow loading page sections due to database calls
    or other processes, we can leverage
    [Streaming](/blogs/streaming-server-side-rendering) to ensure that
    the rest of your page content is displayed promptly without being
    held back by slower components.
  </div>
</Conversation.Thread>

<Conversation.Thread from="user">
  Thanks Chat ! This helps a lot. Any final tips?
</Conversation.Thread>

<Conversation.Thread from="server">
  You're welcome! Remember that Server Components can significantly
  enhance the performance and user experience of your web
  applications. Use them strategically to offload work from the client
  to the server, and combine them with Client Components for
  interactivity. Keep experimenting and monitoring your application‚Äôs
  performance to get the best results.
</Conversation.Thread>

<Conversation.Thread from="browser">
  Stay tuned for our next conversation where we‚Äôll dive into more
  advanced techniques for optimizing web performance. See you next
  time!
</Conversation.Thread>

<Conversation.Thread from="user">
  Looking forward to it!
</Conversation.Thread>

{' '}

<Conversation.Thread from="me">
  Thanks for taking the time to read my article! I'd love to hear your
  feedback ‚Äì any questions, suggestions, or different perspectives are
  welcome. Your input helps me improve and create even better content.
  Feel free to follow me and continue the conversation [on
  ùïè](https://x.com/HamzaMiloudAma1) to continue the discussion.
</Conversation.Thread>

</Conversation>

Thank you for joining us in exploring React Server Components. In our next
post, we'll discuss [Resumability](/blogs/resumability),
a concept that ensures applications can resume their state seamlessly across
server and client interactions. Goodbye for now, and see you in our final
discussion on [Resumability](/blogs/resumability)!
