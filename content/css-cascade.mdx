---
title: 'CSS Cascade: How the Browser Determines the Final styles'
excerpt: 'master the CSS cascade: Learn about origin, context, inline styles, cascade layers, specificity, scope, proximity, and order of appearance.'
image: '/assets/blog/cascade/cascade.webp'
publishedAt: '2024-09-02T05:35:07.322Z'
lastModified: '2024-09-02T05:35:07.322Z'
author:
  name: Hamza Miloud amar
  picture: '/me.jpg'
tags: ['Rendering Pattern', 'Hydration', 'Web Performance', 'React']
---

In this post we‚Äôll go deeper into CSS cascade, one of the core CSS concepts that I believe everyone should understand. this concept can be tricky even for experienced developers. We‚Äôll help you understand why your styles don‚Äôt work as expected or why certain styles are applied even though you didn‚Äôt add them.

I believe the best way to achieve this understanding is by combining theory and practice and that‚Äôs what we‚Äôll do in this article.

By the end of this article, you'll have the knowledge and the confidence to resolve CSS conflicts,
ensuring your styles always behave as expected.

## What is CSS cascade?

The CSS cascade is an algorithm used by the User Agent (browser) to resolve conflicts when the same declaration is added multiple times to the selected element(s). The browser attempts to select the correct declaration to apply. The CSS cascade uses several layers to filter and determine which property will be applied. Sometimes the browser goes through all of these layers to resolve the conflict, but other times it can be resolved in the first layer(s). These layers are:
`Importance and origin`, `context`, `inline style`, `cascade layer` , `specificity`, `scope proximity` , and `order of appearance`.

Let's dive into each one of these layers and do some practice to understand how the browser uses the CSS cascade to determine which properties win.

## CSS cascade: Origin and Importance

The origin of a declaration is based on where it comes from. In CSS, there are three main origins:

**Author stylesheets**: styles that we add as developers.

**User stylesheets**: styles set by the operating system or browser extensions. These allow users to customize their web experience, such as increasing font size or using a dark mode extension ...etc.

**User Agent stylesheets**: Default styles provided by the browser. These are the styles that browsers apply to HTML elements. For example, the default margin around paragraphs or the styling of form elements.

This layer is responsible for resolving conflicts between origins, To accomplish that, it has a set of rules that simplify this process. you can see this illustrated in the image below, where the order is from top (high priority) to bottom (low priority).

![CSS cascade origin and importance hierarchy diagram. From highest to lowest priority: Transition declarations, Important User Agent, Important user, Important author, Animation, Normal author, Normal user, Normal User Agent. The diagram uses color-coded bars to represent each level, with an arrow indicating the order from top (highest priority) to bottom (lowest priority).](/assets/blog/cascade/origin.png)

The skyblue bars in the illustration above; describe the priority of each origin in normal declaration, and show that the author has the highest priority. The css Group doesn't want our styles(Author) to be prioritize in all cases, we need some sort of balance. This is where Important came in handy. When we add `!important` to a declaration, it creates another layer of priority with flipped order, Look at the purple bars above, where the author has the lowest priority; this creates the balance that we talk about, and this is the main reason why `!important` exists not to be used as a hack to force some declaration to be applied in our code.

<Alert
  color="p"
  message="This behavior of !important is not exclusive to the Origins layer but also applies to other layers such as Context and Cascade Layer, which we will discuss in the next CSS cascade sections."
  title="Note About Important Declarations"
/>

Let's make our hand dirty by doing an example that demonstrates a set of conflicts and how cascade origin and importance layer are going to resolve them.

```html
<div
  style="background: white;background:pink !important"
  id="hero"
  data-type="full"
>
  Hello world
</div>
```

```css
/* üö®LET's PRENTEND THAT THIS IS A USER AGENT STYLE  üö® */
div {
  display: block;
  text-align: end;
  color: #eee !important;
}

div[data-type='full'] {
  width: 100% !important;
}

/* üö®LET's PRENTEND THAT THIS IS A USER STYLE THE USER USE AN CHROME EXTENSION TO FORCE DARK MODE  üö® */
div {
  font-size: 2rem;
  background-color: black;
  color: white !important;
  text-align: center;
}

/* üö® AUTHOR STYLE START üö® */
#hero {
  height: 500px;
  text-align: start;
  color: #efe !important;
  background-color: brown !important;
  background: green;
}
```

<Alert
  color="p"
  message="I'd like to highlight a common mistake some people make by considering specificity at this stage, thinking they need to increase it to override (User, User Agent) styles. Specificity is the fifth layer in the cascade, and we don't think about it until we reach that specific layer."
  title="Don't Overthink Specificity"
/>
In this example, we aim to highlight all potential scenarios of a conflict,
including those with only normal declarations, those with only important
declarations, and those with both. But before going through the conflict,
let's begin by identifying styles that don't have any conflicts; they will
apply directly to the selected element(s) without the need for cascade
resolution.

```css
display: block; // USER AGENT (No conflict) ‚úÖ
width: 100% !important; // USER AGENT important (No conflict) ‚úÖ
font-size: 2rem; // USER (No conflict) ‚úÖ
height: 500px; // AUTHOR (No conflict) ‚úÖ
```

Let's begin with normal declaration conflicts where no `!important` rule is applied. The order of precedence from highest to lowest: author, user, and user agent styles. Therefore, the declaration from the author will be applied.

```css
text-align: start; // AUTHOR (Wins) ‚úÖ
text-align: center; // USER (Overridden) ‚ùå
text-align: end; // USER AGENT (Overridden) ‚ùå
```

After we went through `!important` flag in all declarations, the usual cascade priority is flipped. In this case, User Agent stylesheets become higher than the user and author.

```css
color: #eee !important; // USER AGENT important (Wins) ‚úÖ
color: white !important; // USER important (Overridden) ‚ùå
color: #efe !important; // AUTHOR important (Overridden) ‚ùå
```

Normal and important declarations are treated separately, even if they come from the same origin. In our example, author styles with `!important` are in a different stage than normal author styles.

<Alert
  color="p"
  message="Pay attention to the comments in the code below. Each comment highlights a layer in the important and origin layer."
  title="Read Comments"
/>

```css
/* Layer for User Agent Importance (No declaration) */
/* Layer for User Importance (No declaration) */
/* Layer for AUTHOR Importance (Two Decalrations) */
background-color: brown !important; // üö® AUTHOR important (In Progress) ‚úÖüöß
background-color: pink !important; // üö® AUTHOR  important inlineStyle=true  (In Progress) ‚úÖüöß
/* Layer for AUTHOR Normal (Two Decalrations)*/
background-color: white; // AUTHOR inline (Overridden) ‚ùå
background-color: green; // AUTHOR (Overridden) ‚ùå
/* Layer for User Normal (One Decalration)*/
background-color: black; (Overridden) ‚ùå
/* Layer for User Agent Normal (One Decalration)*/
```

While we have two potential winners, only one of them will apply. The decision is passed to the next layer(s) of the CSS cascade. Remember, the CSS cascade involves multiple layers, this one only resolves conflicts based on origin and importance.

## CSS cascade: Context

The author's (developer) stylesheet has two types of contexts based on where the declaration comes from, either a shadow¬†DOM context or a light¬†DOM context. Let's try to understand each one of them and how it works with the CSS cascade.

**host document (light DOM) context**: is the main DOM tree of a web page; it can host regular or custom html elements, The styles applied in this context affect any element live whithin them;

**shadow DOM context**: it‚Äôs a powerful scoping feature that prevents styles from leaking out or in the component, that means any styles that we add inside a shadow DOM can't affect any element outside, even if they have the same selector, meaning no naming conflict.

In the CSS cascade context layer, we have two types of styles the inner styles (from the Shadow Dom) and the outer styles (from the Light Dom). The outer styles have more priority than the inner styles, and remember the rule we said before that `!important` add new stages above the normal declaration and flip the order, which means inner has high priority. Let's see an example to understand how it works.

<Alert
  color="p"
  message="I want to clarify something so you don't get confused. In the example below, we style the c-button custom element from outside because it lives inside the dom, but anything inside the shadow dom can't be styled from outside."
  title="Styling Shadow"
/>
```html
<template id="button">
  <style>
    :host {
      color: black !important;
      background: red;
      padding: 0.5rem 1.5rem;
      border: 1px solid transparent;
      font-weight: 700;
    }
  </style>
  <button><slot></slot></button>
</template>

<c-button> Hello! </c-button>

````

```css
c-button {
  background: orange;
  color: white !important;
  padding: 1rem 3rem !important;
  text-transform: uppercase;
}
````

```js
customElements.define(
  'c-button',
  class extends HTMLElement {
    connectedCallback() {
      this.attachShadow({ mode: 'open' }).append(
        button.content.cloneNode(true),
      );
    }
  },
);
```

Now that we have a basic understanding of how the context layer works, let's create a code that resolves this issue, then follow these steps below:

1. Put each declaration in its own layer.
2. Add this emoji ‚öîÔ∏è next to declarations that have conflict and üïäÔ∏è to declarations that don't.
3. Visualize from top to bottom and look for the first declaration that has conflict and add ‚úÖ to highlight it as the applied (winner) declaration and ‚ùå to other declaration(s).

```css
/* Important Inner Style  */
color: white !important; //  ‚úÖ ‚öîÔ∏è
padding: 1rem 3rem !important; //  ‚úÖ ‚öîÔ∏è

/* Important Outer Style Layer Context */
color: black !important; //  ‚ùå ‚öîÔ∏è

/* Normal Outer Style Layer Context */
background: red; //  ‚úÖ ‚öîÔ∏è
padding: 0.5rem 1.5rem; //  ‚ùå ‚öîÔ∏è
border: 1px solid transparent; //  ‚úÖ üïäÔ∏è
font-weight: 700; //  ‚úÖ  üïäÔ∏è

/* Normal Inner Style Layer Context */
background: orange; //  ‚ùå ‚öîÔ∏è
text-transform: uppercase; //  ‚úÖ üïäÔ∏è
```

## CSS cascade: inline style

Inline styles are styles that apply directly to HTML elements. They're the third layer of the cascade, and they're not part of the CSS cascade specificity layer as some people suggest; they have their own layer. Let's do some examples to understand how it works.

Let's get back to the example from last time about the¬†`background-color`. After resolving the conflict in origin and importance, we got two winners. Let's check if we can resolve this conflict in this layer or pass it to the next one.

After visualizing the conflict, I see that we have two declarations, both with `!important`, and one comes from an inline style. That means the inline style wins.

```css
background-color: pink !important; // AUTHOR  important inline=true (Wins)‚úÖ
background-color: brown !important; // AUTHOR important (Overridden)‚ùå
```

## CSS Cascade: Cascade Layer

CSS Cascade Layers is the fourth layer in CSS Cascade, allowing you to take control of your code by making some of your stylesheets have higher priority than others by putting them within a layer. This is a list that show the basic features of the cascade layers.

- The order of the layers is from top (less priority) to bottom (high priority).
- Styles without a layer have the most priority, but in the future we can explicitly control the order of unlayered styles. [There's a proposal open by mirisuzanne for more detail](https://github.com/w3c/csswg-drafts/issues/6323)
- Cascade layer has a feature that merges the layers with the same name in the first declared one.

- We can use a layer at the top that is responsible for reordering the under layers; the left layer has less priority than the right ones Example: `@layer reset components utils;`.
- Remember the rule we said before about `!important`, when it is added to a declaration it's introduces new stages above the normal ones in a reversed order let's let's an example for this layer `@layer reset utils;`.
  - Important reset;
  - Important utils;
  - Important Unlayered Style;
  - Normal Unlayered Style;
  - Normal utils;
  - Normal reset;

```css
@layer reset components utils;

@layer utils {
  button: {
    color: orange;
    border-bottom: 2px solid var(--red-8);
  }
}

@layer components {
  button: {
    color: red;
    border-bottom: 2px solid var(--red-8) !important;
  }
}
@layer reset {
  button {
    color: white;
    padding: 1rem !important;
    appearance: none;
  }


button {
  color: green;
  padding: 0;
  border-bottom: 2px dashed var(--red-8) !important;
}
```

<Alert
  color="p"
  message="Pay attention to the comments in the code below. Each comment highlights a layer in this cascade layer example below."
  title="Read Comments"
/>

```css
/* Layer for reset Importance  */
padding: 1rem !important; //  ‚úÖ ‚öîÔ∏è

/* Layer for components Importance  */
border-bottom: 2px solid var(--red-8) !important; // ‚úÖ ‚öîÔ∏è

/* Layer for utils Importance */

/* No Layer Style  Important */
border-bottom: 2px dashed var(--red-8) !important; // ‚ùå  ‚öîÔ∏è

/* No Layer Style  Normal */
color: green; // ‚úÖ ‚öîÔ∏è
padding: 0; // ‚ùå ‚öîÔ∏è

/* Layer for utils Normal */
color: orange; // ‚úÖ ‚öîÔ∏è
border-bottom: 2px solid var(--red-8); // ‚ùå ‚öîÔ∏è

/* Layer for components Normal  */
color: red; // ‚ùå ‚öîÔ∏è

/* Layer for reset Normal  */
appearance: none; // ‚úÖ üïäÔ∏è
color: white; // ‚ùå ‚öîÔ∏è
```

<Alert
  color="p"
  message="I'd like to highlight a common mistake some people make by considering specificity at this stage, specificity is the fifth layer in the cascade"
  title="Don't Overthink Specificity"
/>

In the example below, the button type selector is applied even when the ID and class have higher specificity. This is because cascade layers are evaluated before specificity in the cascade algorithm, and the button type selector isn't in any layer remember that unlayered styles has the highest priority, followed by the utils , then component layer in normal declarations in the example below.

```html
<button id="btn" class="u_btn-orange">hello</button>
```

```css
button {
  background: green;
}

@layer components {
  #btn {
    background: red;
  }
}

@layer utils {
  .u_btn-orange {
    background: orange;
  }
}
```

```css
/* Important components Layer */

/* Important utils Layer */

/* Important Unlayered Layer */

/* Normal Unlayered Layer */

background: green; // ‚úÖ ‚öîÔ∏è
/* Normal utils Layer */
background: orange; // ‚ùå  ‚öîÔ∏è

/* Normal components Layer */
background: red; // ‚ùå  ‚öîÔ∏è
```

## CSS Cascade: Specificity

Specificity is an algorithm that calculates the weight of a CSS selector used by the user agent (browser) to determine the winner when conflict exists and isn't solved by the previous layers.

Every CSS selector has a score, and the specificity uses this score to resolve conflict, but before begin speaking about the specificity, let's talk first about the CSS selector and the score of each one of them.

### No specificity selector

- **Universal Selector (\*)**: This selector select all elements.
- **:is(), :not(), and :has()**: This pseudo class selectors has no specificity, but the selector whitin them has specificity.
- **:where()**: This pseudo class selector and the selector whitin it has no specificity.

```css
* {
}

section:has(img) {
}

:where(.btn) {
}

:is(button, a, .btn):hover {
}
```

### 0.0.1 specificity score

- **Type Selector**: Selects all elements that match a specific tag name. For example `p` to select all `<p>` elements.
- **pseudo-element**: Used to style a specific part of an element or insert content that doesn't exist, prefixed with `::` for example `::before` to insert element as the first child of the selected element.

```css
/* Type Selector */
p {
}
ol,
ul {
}
/* Pseaudo element Selector */
::before {
}
::after {
}
```

### 0.1.0 specificity score

- **Class**: matches all element that has a class attribute with same value as the selector prefixed with `.`.
- **Pseudo-class**: A keyword added to the selected element for a specific state, prefixed with a colon `:` like `:hover` , `:focus` and `:disabled`.
- **Attribute Selector**: select all element that has an attribute with same value as the selector within a `[Attribute Here]` for example `[disabled]` or `[type="button"]`.

```css
/* Class Selector */
.btn {
}
/* Pseaudo-Class Selector */
:focus {
}

:disabled {
}
/* Attribute Selector */
[aria-current='page'] {
}
[disabled] {
}
```

### 1.0.0 specificity score

- **ID Selector:** Select the element that has id attribute same to the selector prefixed with #.

```css
/* ID Selector */
#btn {
}
```

**Comma Separator**: Doesn't combine weight of all selectors but each selector(s) between comma has it own weight.

```css
/* 0.2.0 */
.btn:hover,
/* 0.1.1 */
button:hover,
/* 0.2.1 */
input[type='button']:hover {
}
```

Let's make a note before diving into the examples. Our scoring system consists of three independent numbers that adhere to a strict rule:

- each number has a selector(s) that increases its value, (take a look at the section above about scoring of each selector).
- `1.0.0` is not equal to `100` and `0.1.5` isn't `15`
- `0.36.0` will never be `3.6.0`.
- `1.0.0` is greater than `0.36.0`
- To compare two scores, we start by the leftmost number, the score with the higher leftmost win. If the leftmost numbers are equal, we compare the middle, and so on.

Okay, now that we have an idea of how specificity scoring systems work and how we choose the winner, let's create some examples to solidify our understanding and explore how we can tackle some common issues we encounter when working with specificity.

```html
<button class="btn" id="gmail">Hello world</button>
```

```css
/* Score is 1.0.0 */
#gmail {
  background: red;
}
/* Score is 0.1.0 */

.btn {
  background: blue;
}
/* Score is 0.2.0 */

.btn:focus {
  background: brown;
}
/* Score is 0.2.0 */
.btn:hover {
  background: orange;
}
```

If you look at this example carefully, you will see that we have conflict in the background declarations,and one of the declaration within an ID selector, which means you can‚Äôt override it no matter how many classes or other selectors you add. That means the focus and disabled background never applied. You can override the ID selector only by either ID or `!important`. This is why people suggest that using ID as a selector is a bad habit to fix this issue. Let‚Äôs replace ID with `btn-gmail` class selector.

```html
<input type="submit" class="btn" />
```

```css
/* 
  Reset Style Section
  Score is 0.1.1
*/
input[type='submit'] {
  background: none;
}
/* 
  Component Style Section
  Score is 0.1.0
*/
.btn {
  background: blue;
}
```

In this example, we try to add a reset, but the specificity of the selector `input[type='submit']` in the reset section is over the class `.btn`. To fix this, we need to remove one of the selectors, but sometimes we can't, like in this example. What we need to do in this scenario is either wrap the whole reset styles in an @layer at-role we spoke about in the previous section, or wrap the selector¬†`input[type='submit']`¬†either with¬†`:is` or¬†`:where`¬†selectors.

Let's explain what `:where` and `:is` doing but only the related part of the cascade. [For more information, check this article.]('https://web.dev/articles/css-is-and-where') . Sometimes we need to combine selectors like what we do in the reset. When we do that, the specificity of the selectors combined gets higher. This is where `:is` and `:where` come to the rescue; both of them reduce the specificity of the selectors within them, but with only one small difference `:is` get the score of the higher selector within them, and `:where` removes the specificity. To make this clear, let's do some examples.

```css
/* 0.2.3 */
label input[type='button']:focus::before {
  outline: 2px solid red;
}
/* 0.0.0 */
:where(label input[type='button']:focus::before) {
  outline: 2px solid red;
}
/* 0.1.0 */
:is(label input[type='button']:focus::before) {
  outline: 2px solid red;
}
/* 1.1.1 */
/* Because the :focus and ::before outside the is */
:is(#pillar-ui #new #react #design #system):focus::before {
  outline: 2px solid red;
}

/* 0.1.1 */
/* Because the :focus and ::before outside the :where */
:where(#pillar-ui #new #react #design #system):focus::before {
  outline: 2px solid red;
}
```

## CSS Cascade: Scope Proximity

Before scope proximity was introduced, the CSS cascade resolved conflict that still persists after specificity by order of appearance layer. But this is not the case for all situations; sometimes we want the element to be styled depending on the near ancestor. Scope proximity is a new layer added before order of appearance that tries to resolve conflicts by considering how close an element is to its scope root (ancestor). The closer it is, the higher its priority. Let's try to add an example to show you the issue and how we can solve it.

```html
<section lang="en">
  <button>hello</button>
  <section lang="ar">
    <button>ÿßÿ≥ÿ™ÿ∑ŸÑÿßÿπ</button>
  </section>
</section>
```

```css
button {
  background: var(--p);
}

[lang='ar'] * {
  --p: brown;
}

[lang='en'] * {
  --p: orange;
}
```

In the example above, all elements descendant of the `lang="ar"` are also descendant of `lang="en"`. CSS is not designed for scope by default, which means to resolve this conflict, CSS relies on order of appearance; because of that, the last declared rule takes precedence and all the elements will be orange. Well, that's not what we did intentionally; we want all elements inside the `[lang='ar']` to be brown because this is the closest ancestor. To achieve this, we have two options in CSS:

**Add a Class**: We could add a CSS class `theme-ar` to manually set the background color. However, this is not an optimal solution; we need to add the class to every element inside the Arabic language three, which increases maintenance, and if we add other languages, it gets worse.

**`@scope` at-Rule**: The second solution is the at-rule `@scope` that adds scope proximity layer to the css cascade. In this way we could solve the conflict we wanted, Let's do that on the example below. [This feature isstill not availabile across all major browsers](https://caniuse.com/css-cascade-scope).

```css
button {
  background: var(--p);
}

@scope ([lang='ar']) {
  button {
    --p: brown;
  }
}

@scope ([lang='en']) {
  button {
    --p: orange;
  }
}
```

## CSS Cascade: Order Of Appearance

Order of appearance is the last layer of the cascade, and if the conflicts still persist, the last declaration takes precedence. This layer seems simple, depending on the size of the stylesheet, but believe me, it's not. I think this is the most difficult layer in the cascade all others layers follow some a simpler rule to identify the conflict. You need to structure your stylesheet in certain ways and follow some naming conventions to make it simpler to know which declarations are going to override which only by looking at the name of the class without looking at the entire stylesheet. But dont worry, I want to write a deep dive on how we can write a scalable CSS code with modern CSS features in the future. Stay tuned. Let's explore some examples and address common issues.

```html
<button class="btn btn_facebook">hello</button>
```

```css
.btn {
  padding: 1rem; //  (Overridden) ‚ùå
}

.btn_facebook {
  padding: 1.5rem; //  (Overridden) ‚ùå
  padding: 2rem; //  (Win) ‚úÖ
}
```

The key point here is that when a conflict exists, the rule that appears last takes precedence. This is why the last `padding: 2rem;` is applied.

Another thing to pay attention to is that declaring shorthand versions of CSS properties will often clear or reset previously set values. like with background property, as we seen in the example below.

```css
.btn {
  background-image: url('/button.png');
  background: orange;
}
```

This behavior is not peculiar to the background property; other shorthand properties act similarly. Once used, they reset all their sub-properties to their default values, except if explicitly set in the shorthand declaration, and this is an example of what it means when we write `background:orange`.

```css
background-image: none;
background-position: 0% 0%;
background-size: auto auto;
background-repeat: repeat;
background-origin: padding-box;
background-clip: border-box;
background-attachment: scroll;
background-color: orange;
```

When using shorthand properties remember what other styles you may be overriding or you can write longhand after shorthand like in this example below.

```css
.btn {
  background: orange;
  background-image: url('/button.png');
}
```

I hope you enjoyed this deep dive article about CSS cascade and helped you improve your knowledge and skills to tackle CSS cascade conflict effectively. To get the best out of this article, I already provide a set of challenges to practice and solidify your understanding. Please try to solve them. [This is the Github CSS Cascade Challenges Repo](https://github.com/HamzaMiloud/cascade-challenges).

## Let's Connect

Your comments and opinions are most welcome! Feel free to let me know whether you have any views on this article, find an inaccuracy, or a better way of doing something‚Äîlet me know! You can reach me on Twitter [@HamzaMiloudAma1](https://x.com/HamzaMiloudAma1), and let's continue from there! .
