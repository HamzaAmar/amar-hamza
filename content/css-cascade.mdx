---
title: 'CSS Cascade: How the Browser Determines the Final styles'
excerpt: 'Css cascade deep dive article that explain in detail'
image: '/assets/blog/rendering/hydration.webp'
publishedAt: '2024-09-02T05:35:07.322Z'
lastModified: '2024-09-02T05:35:07.322Z'
author:
  name: Hamza Miloud amar
  picture: '/me.jpg'
tags: ['Rendering Pattern', 'Hydration', 'Web Performance', 'React']
---

In this post we‚Äôll go deeper into css cascade, one of the core CSS concepts that I believe everyone should understand. this concept can be tricky even for experienced developers. We‚Äôll help you understand why your styles don‚Äôt work as expected or why certain styles are applied even though you didn‚Äôt add them.

I believe the best way to achieve this understanding is by combining theory and practice and that‚Äôs what we‚Äôll do in this article.

By the end of this article, you'll have the knowledge and the confidence to resolve CSS conflicts,
ensuring your styles always behave as expected.

## What is css cascade?

The css cascade is an algorithm used by the User Agent (browser) to resolve conflicts when the same declaration is added multiple times to the selected element(s). The browser attempts to select the correct declaration to apply. The css cascade uses several layers to filter and determine which property will be applied. Sometimes the browser goes through all of these layers to resolve the conflict, but other times it can be resolved in the first layer(s). These layers are:
`Importance and origin`, `context`, `inline style`, `cascade layer` , `specificity`, `scope proximity` , and `order of appearance`.

Let's dive into each of these layers and do some practice to understand how the browser uses the css cascade to determine which properties win.

## CSS cascade: Origin and Importance

The origin of a declaration is based on where it comes from. In CSS, there are three main origins:

**Author stylesheets**: styles that we add as developers.

**User stylesheets**: styles set by the operating system or browser extensions for user preferences. These allow users to customize their web experience, such as increasing font size for readability or using a dark mode extension ...etc.

**User Agent stylesheets**: Default styles provided by the User Agent (browser). These are the styles that browsers apply to HTML elements. For example, the default margin around paragraphs or the styling of form elements.

As we've seen before, styles come from different origins, not only from authors (developers). This layer is responsible for resolving conflicts between origins, To accomplish that, it has a set of rules that simplify this process. you can see this illustrated in the image below, where the order is from top (high priority) to bottom (low priority).

![CSS cascade origin and importance hierarchy diagram. From highest to lowest priority: Transition declarations, Important User Agent, Important user, Important author, Animation, Normal author, Normal user, Normal User Agent. The diagram uses color-coded bars to represent each level, with an arrow indicating the order from top (highest priority) to bottom (lowest priority).](/assets/blog/cascade/origin.png)

Look at the blue bars in the illustration above; its describe the priority of each origin and show that the author has the highest priority. The CSS Group wants your style to be applied. but not in all cases we want some sort of balance. This is where Important came in handy. When `!important` adds to a declaration, it creates another stages Look at the purple bars in the illustration above, where the author has the lowest priority; this creates the balance that we talk about, and this is the main reason why `!important` exists not to be added as a hack to force some declaration to be applied.

<Alert
  color="p"
  message="This important behavior is not exclusive to the Origins layer but also applies to other layers such as Context and Cascade Layer, which we will discuss in the next css cascade sections."
  title="Not About Important Declarations"
/>

Let's make our hand dirty by doing an example that demonstrates a set of conflicts and how cascade origin and importance layer are going to resolve them.

```html
<div
  style="background: white;background:pink !important"
  id="hero"
  data-type="full"
>
  Hello world
</div>
```

```css
/* üö®LET's PRENTEND THAT THIS IS A USER AGENT STYLE  üö® */
div {
  display: block;
  text-align: end;
  color: #eee !important;
}

div[data-type='full'] {
  width: 100% !important;
}

/* üö®LET's PRENTEND THAT THIS IS A USER STYLE THE USER USE AN CHROME EXTENSION TO FORCE DARK MODE  üö® */
div {
  font-size: 2rem;
  background-color: black;
  color: white !important;
  text-align: center;
}

/* üö® AUTHOR STYLE START üö® */
#hero {
  height: 500px;
  text-align: start;
  color: #efe !important;
  background-color: brown !important;
  background: green;
}
```

<Alert
  color="p"
  message="I'd like to highlight a common mistake some people make by considering specificity at this stage, thinking they need to increase it to override (User, User Agent) styles. Specificity is the fifth layer in the cascade, and we don't think about it until we reach that specific layer."
  title="Don't Overthink Specificity"
/>
In this example, we aim to highlight all potential scenarios of a conflict,
including those with only normal declarations, those with only important
declarations, and those with both. But before going through the conflict,
let's begin by identifying styles that don't have any conflicts; they will
apply directly to the selected element(s) without the need for cascade
resolution.

```css
display: block; // USER AGENT (No conflict) ‚úÖ
width: 100% !important; // USER AGENT important (No conflict) ‚úÖ
font-size: 2rem; // USER (No conflict) ‚úÖ
height: 500px; // AUTHOR (No conflict) ‚úÖ
```

Let's begin by normal declaration conflicts where no `!important` rule is applied. The order of precedence from highest to lowest: author, user, and user agent styles. Therefore, the declaration from the author will be applied.

```css
text-align: start; // AUTHOR (Wins) ‚úÖ
text-align: center; // USER (Overridden) ‚ùå
text-align: end; // USER AGENT (Overridden) ‚ùå
```

After we went through `!important` flag in all declarations, the usual cascade priority is flipped. In this case, User Agent stylesheets become higher than the user and author

```css
color: #eee !important; // USER AGENT important (Wins) ‚úÖ
color: white !important; // USER important (Overridden) ‚ùå
color: #efe !important; // AUTHOR important (Overridden) ‚ùå
```

Normal and important declarations are treated separately, even if they come from the same source (like the author). In our example, author styles with `!important` are in a different stage than normal author styles.

<Alert
  color="p"
  message="Pay attention to the comments in the code below. Each comment highlights a layer in the important and origin layer."
  title="Read Comments"
/>

```css
/* Layer for User Agent Importance (No declaration) */
/* Layer for User Importance (No declaration) */
/* Layer for AUTHOR Importance (Two Decalrations) */
background-color: brown !important; // üö® AUTHOR important (In Progress) ‚úÖüöß
background-color: pink !important; // üö® AUTHOR  important inlineStyle=true  (In Progress) ‚úÖüöß
/* Layer for AUTHOR Normal (Two Decalrations)*/
background-color: white; // AUTHOR inline (Overridden) ‚ùå
background-color: green; // AUTHOR (Overridden) ‚ùå
/* Layer for User Normal (One Decalration)*/
background-color: black; (Overridden) ‚ùå
```

While we have two potential winners, only one of them will apply. The decision is passed to the next layer(s) of the css cascade. Remember, the css cascade involves multiple layers, this one only resolves conflicts based on origin and importance.

## CSS cascade: Context

The author (Developer) stylesheet have Two types of contexts based on where the declaration come from either `shadow DOM context` or `light DOM context`. let's try to understand each one of them and how it works with the css cascade.

**host document (light DOM) context**: styles that we add as developers.

**shadow DOM context**: it‚Äôs a powerful scoping feature, that prevent styles from leaking out or in the componet, That means any styles that we add inside a shadow dom never affect any element outside even if they have the same selector means no naming conflict.

In css cascade Context layer we have two type of styles the inner (Shadow Dom) and the outer (host document or Light Dom) styles, the Outer styles has more priority than the inner styles and remember the rule we say before that `!important` add new stages above the normal declaration and flip the order means inner has high priority. Let's see an example to understand how it works.

```html
<template id="button">
  <style>
    :host {
      color: black !important;
      background: red;
      padding: 0.5rem 1.5rem;
      border: 1px solid transparent;
      font-weight: 700;
    }
  </style>
  <button><slot></slot></button>
</template>

<c-button> Hello! </c-button>
```

```css
c-button {
  background: orange;
  color: white !important;
  padding: 1rem 3rem !important;
  text-transform: uppercase;
}
```

```js
customElements.define(
  'c-button',
  class extends HTMLElement {
    connectedCallback() {
      this.attachShadow({ mode: 'open' }).append(
        button.content.cloneNode(true),
      );
    }
  },
);
```

Now that we have a basic understanding of how the Context layer works, lets create a code that resolve this issues then follow this steps below:

1. Put each declaration in its own layer.
2. Add this emoji ‚öîÔ∏è next to declarations that have conflict and üïäÔ∏è to declarations that don't.
3. Visualize from top to bottom and look for the first declaration that has conflict and add ‚úÖ to highlight it as the applied (winner) declaration and ‚ùå to other declaration(s).

```css
/* Important Inner Style  */
color: white !important; //  ‚úÖ ‚öîÔ∏è
padding: 1rem 3rem !important; //  ‚úÖ ‚öîÔ∏è

/* Important Outer Style Layer Context */
color: black !important; //  ‚ùå ‚öîÔ∏è

/* Normal Outer Style Layer Context */
background: red; //  ‚úÖ ‚öîÔ∏è
padding: 0.5rem 1.5rem; //  ‚ùå ‚öîÔ∏è
border: 1px solid transparent; //  ‚úÖ üïäÔ∏è
font-weight: 700; //  ‚úÖ  üïäÔ∏è

/* Normal Inner Style Layer Context */
background: orange; //  ‚ùå ‚öîÔ∏è
text-transform: uppercase; //  ‚úÖ üïäÔ∏è
```

## CSS cascade: inline style

Inline styles are styles that apply directly to HTML element. They're the third layer of the cascade, and they're not part of the css cascade specificity layer as some people suggest; they have their own layer. Let's do some examples to understand how it works.

Let's get back to the last examples from last time about the¬†`background-color`.After resolving the conflict in origin and importance, we got two winners. Let's check if we can resolve this conflict in this layer or pass it to the next one.

After visualizing the conflict, I see that we have two declarations, both with !important, and one comes from an inline style. That means the inline style wins.

```css
background-color: pink !important; // AUTHOR  important inline=true (Wins)‚úÖ
background-color: brown !important; // AUTHOR important (Overridden)‚ùå
```

## CSS Cascade: Cascade Layer

CSS Cascade Layers is the fourth layer in cascade, allowing you (developer) to take control in your code by making some of your stylesheets have higher priority than others by putting them within a layer. The first declared layer has less priority than the last ones, and the styles without a layer have the most priority, when important is added, the order of the layers is flipped. If you look carefully you find this layer similar to the origin and importance layer but for your own styles.

```css
@layer reset components utils;

@layer utils {
  button: {
    color: orange;
    border-bottom: 2px solid var(--red-8);
  }
}

@layer components {
  button: {
    color: red;
    border-bottom: 2px solid var(--red-8) !important;
  }
}
@layer reset {
  button {
    color: white;
    padding: 1rem !important;
    appearance: none;
  }


button {
  color: green;
  padding: 0;
  border-bottom: 2px dashed var(--red-8) !important;
}
```

In this example, I add four at-rule layers; the first layer is responsible for reordering the layers, the cascade layer has a feature that merges the layers with the same name in the first declared one, I usually use this feature even when the order is correct to give me a hint for which layer has the most priority without looking at the entire stylesheet.

Now that we have a basic understanding of how the cascade layer works, it's simple to resolve these conflicts by following these steps.

1. Put each declaration in its own layer.
2. Add this emoji ‚öîÔ∏è next to declarations that have conflict and üïäÔ∏è to declarations that don't.
3. Visualize from top to bottom and look for the first declaration that has conflict and add ‚úÖ to highlight it as the applied (winner) declaration and ‚ùå to other declaration(s).

<Alert
  color="p"
  message="Pay attention to the comments in the code below. Each comment highlights a layer in this cascade layer example below."
  title="Read Comments"
/>

```css
/* Layer for reset Importance  */
padding: 1rem !important; //  ‚úÖ ‚öîÔ∏è

/* Layer for components Importance  */
border-bottom: 2px solid var(--red-8) !important; // ‚úÖ ‚öîÔ∏è

/* Layer for utils Importance */

/* No Layer Style  Important */
border-bottom: 2px dashed var(--red-8) !important; // ‚ùå  ‚öîÔ∏è

/* No Layer Style  Normal */
color: green; // ‚úÖ ‚öîÔ∏è
padding: 0; // ‚ùå ‚öîÔ∏è

/* Layer for utils Normal */
color: orange; // ‚úÖ ‚öîÔ∏è
border-bottom: 2px solid var(--red-8); // ‚ùå ‚öîÔ∏è

/* Layer for components Normal  */
color: red; // ‚ùå ‚öîÔ∏è

/* Layer for reset Normal  */
appearance: none; // ‚úÖ üïäÔ∏è
color: white; // ‚ùå ‚öîÔ∏è
```

<Alert
  color="p"
  message="I'd like to highlight a common mistake some people make by considering specificity at this stage, specificity is the fifth layer in the cascade"
  title="Don't Overthink Specificity"
/>

In the example below, the button type selector is applied even when the ID and class have higher specificity. This is because cascade layers are evaluated before specificity in the cascade algorithm, and unlayered styles have the highest priority, followed by the utils layer, then the component layer in normal declarations.

```html
<button id="btn" class="u_btn-orange">hello</button>
```

```css
button {
  background: green; // ‚úÖ ‚öîÔ∏è
}

@layer components {
  #btn {
    background: red; // ‚ùå  ‚öîÔ∏è
  }
}

@layer utils {
  .u_btn-orange {
    background: orange; // ‚ùå ‚öîÔ∏è
  }
}
```

## CSS Cascade: Specificity

Specificity is a an algorithm that calculate the weight of a css selector use by the User Agent (Browser), to determine the winner when conflict exist and doesn't solved by the previous layers, as we saw before that cascade has multiple layers, specificity is the fifth layer

Every CSS selector has a score and the specificity use this score to resolve conflict but before begin speaking about the specificity let's talk first about css selector and the score of each one of them

**Universal Selector (\*), :is(), :where() , :not(), :has()**: Has a no specificity.

```css
* {
}

section:has(img) {
}

:where(.btn) {
}

:is(button, a, .btn):hover {
}
```

**Type Selector or pseudo-element**: Has a specificity score of **0.0.1**.

```css
/* Type Selector */
p {
}
ol,
ul {
}
/* Pseaudo element Selector */
::before {
}
::after {
}
```

**Class, pseudo-class,and Attribute Selector**: Has a specificity score of **0.1.0**.

```css
/* Class Selector */
.btn {
}
/* Pseaudo-Class Selector */
:focus {
}

:disabled {
}
/* Attribute Selector */
[aria-current='page'] {
}
[disabled] {
}
```

**ID Selector**: Has a specificity score of **1.0.0**.

```css
/* ID Selector */
#btn {
}
```

<Alert
  color="p"
  message="Comma Separator Doesn't combine weight of all selectors but each selector(s) between comma has it own weight"
  title="Comma Separator"
/>

```css
/* ID Selector */
/* 0.1.0 */
.btn,
/* 0.0.1 */
button,
/* 0.1.1 */
input[type='button'] {
}
```

Let's make a note before diving into the examples. Our scoring system consists of three independent numbers that adhere to a strict rule: each number has some selector(s) that increases its value. Don't confuse this with math, which means even when we have a score of `0.36.0`, it will never be `3.6.0`. Each number has only one way to increase it, and that is the selector, and also `1.0.0` is greater than `0.1000000000.0`

```css
/* Score 0.1.0 */
.btn {
  background: red; //  (Overridden) ‚ùå
}
/*
üö® let's pretend that we add class .btn 12 times üö®
 The Score in here IS 0.12.1
 üö®
 */
button.btn.btn.btn.btn.btn.btn.btn.btn.btn {
  background: red; //  (Overridden) ‚ùå
}
/* Score 1.0.0 */
#id {
  background: brown; //  (Wins) ‚úÖ
}
```

Okay, now that we have an idea of how specificity scoring systems work and how we choose the winner, let's create a real-world example to solidify our understanding and explore how we can tackle some common issues we encounter when working with specificity.

```css
/* ---- Reset Style Start ---- */

/* Score is 0.0.0 */
* {
  background: white;
}
/* Score is 0.0.1 */
button,
/* Score is 0.1.1 */
input[type='submit'] {
  cursor: inherit;
  appearance: none;
  border: none;
}

/* ---- Reset Style End ---- */

/* Score is 1.0.0 */
#gmail {
  background: red;
}
/* Score is 0.1.0 */

.btn {
  cursor: pointer;
  background: blue;
}
/* Score is 0.2.0 */

.btn:focus {
  background: brown;
}
/* Score is 0.2.0 */
.btn:hover {
  background: var(--primary-9);
}
.btn:disabled {
  background: var(--primary-9);
}
/* Score is 0.2.0 */

.btn.btn-success {
  background: var(--success-8);
}
/* Score is 0.1.0 */
```

If you look at this example carefully, you will see that we have two conflicts: the background and the cursor. If we take a closer look at the background declarations, you see an ID as a selector, which means you can‚Äôt override it no matter how many classes or other selectors you add. That means the focus and disabled background never applied. You can override the ID selector only by either ID or `!important`. This is why people suggest that using ID as a selector is a bad habit to fix this issue. Let‚Äôs replace ID with `btn-gmail` class selector.

For the cursor, we try to add a reset, but the specificity of the reset is over the class because it combines selector type and an attribute selector. To fix this, we need to remove one of the selectors, but sometimes we can't like in this example. What we need to do in this scenario is either wrap the whole reset styles in an @layer at-role we spoke about in the last section, or wrap the selector¬†`input[type='submit']`¬†either with¬†`:is` or¬†`:where`¬†selectors.

Let's explain what `:where`¬†and¬†`:is` doing but only the related part of the cascade. [for more information check this article]('https://web.dev/articles/css-is-and-where') . Sometimes we need to combine selectors like what we do in the reset. When we do that, the specificity of the selectors combined gets higher. This is where¬†`:is` and¬†`:where` come to the rescue; both of them reduce the specificity of the selectors within them, but with only one small difference `:is` get the score of the higher selector within them, and `:where` remove the specificity. To make this clear, let's do some examples.

```css
/* 0.2.3 */
label input[type='button']:focus::before {
  outline: 2px solid red;
}
/* 0.0.0 */
:where(label input[type='button']:focus::before) {
  outline: 2px solid red;
}
/* 0.1.0 */
:is(label input[type='button']:focus::before) {
  outline: 2px solid red;
}
/* 1.1.1 */
/* Because the :focus and ::before outside the is */
:is(#pillar-ui #new #react #design #system):focus::before {
  outline: 2px solid red;
}

/* 0.1.1 */
/* Because the :focus and ::before outside the :where */
:where(#pillar-ui #new #react #design #system):focus::before {
  outline: 2px solid red;
}
```

## CSS Cascade: Scope Proximity

Before Scope Proximity was introduced, the css cascade resolve conflict that still persist after specificity by order of appearce layer. but this not the cases for all situation sometimes we want the element to be styled depend on the near ancestor. scope proximity is a new layer added before order of appearance that try to resolve conflicts by considering how close an element is to its scope root (ancestor). The closer it is, the higher its priority, let's try to add an example to show you the issue and how we can solve it.

```html
<section lang="en">
  <button>hello</button>
  <section lang="ar">
    <button>ÿßÿ≥ÿ™ÿ∑ŸÑÿßÿπ</button>
  </section>
</section>
```

```css
button {
  background: var(--p);
}

[lang='ar'] * {
  --p: brown;
}

[lang='en'] * {
  --p: orange;
}
```

In the example above, all elements descendant of the `lang="ar"` are also descendant of `lang="en"`, css not designed for scope by default, means if the conflict still persist at this stages of cascade, CSS relies on order of appearace to resolve it, because of that the last declared rule takes precedence and all the elements will be orange. Well, that's not what we did intentionally; we want all elements inside the `[lang='ar']` to be brown because this is the closest ancestor. To achieve this, we have two options in CSS:

**Add a Class**: We could add a CSS class `theme-ar` to manually set the background color. However, this is not an optimal solution because we need to add the class to every element inside the Arabic language three, which increases maintenance, and if we add other languages, it gets worse.

**`@scope` at-Rule**: The second solution and the recommended one is by adding the at-rule `@scope` to add the cascade proximity layer. In this way we could solve the conflict we wanted. Let's do that on the example below.

```css
button {
  background: var(--p);
}

@scope ([lang='ar']) {
  button {
    --p: brown;
  }
}

@scope ([lang='en']) {
  button {
    --p: orange;
  }
}
```

## CSS Cascade: Order Of Appearance

Order of appearance is the last layer of the cascade, and if the conflicts still persist, the last declaration takes precedence. This example seem simple depend of the size of the stylesheet, but believe me, it's not. I think this is the most difficult layer in the cascade. You need to structure your stylesheet in certain ways and follow some naming conventions to make it simpler to know which declarations are going to override which only by looking at the name of the class without looking at the entire stylesheet. But dont worry, I want to write a deep dive on how we can write a scalable CSS code with modern CSS features in the future. Stay tuned. Let's explore some examples and address common issues.

```html
<button class="btn btn_facebook">hello</button>
```

```css
.btn {
  padding: 1rem; //  (Overridden) ‚ùå
}

.btn_facebook {
  padding: 1.5rem; //  (Overridden) ‚ùå
  padding: 2rem; //  (Win) ‚úÖ
}
```

The key point here is when a conflict exist the rule that appears last takes precedence. This is why the last `padding: 2rem;` is applied.

Another thing to pay attention to is that declaring shorthand versions of CSS properties will often clear or reset previously set values. like with background property as we seen in the example below.

```css
.btn {
  background-image: url('/button.png');
  background: orange;
}
```

This behavior is not peculiar to the background property: other shorthand properties act similarly. Once used, they reset all their sub-properties to their default values, except if explicitly set in the shorthand declaration and this is an example of what means when we write `background:orange`.

```css
background-image: none;
background-position: 0% 0%;
background-size: auto auto;
background-repeat: repeat;
background-origin: padding-box;
background-clip: border-box;
background-attachment: scroll;
background-color: orange;
```

When using shorthand properties remember what other styles you may be overriding or you can write longhand after shorthand like in this example below.

```css
.btn {
  background: orange;
  background-image: url('/button.png');
}
```

I hope you enjoyed this deep dive article about css cascade and helped you improve your knowledge and skills to tackle css cascade conflict effectively. to get the best out of this article I already provide a set of challenges to practice and solidify you understanding please try to solve them [this is the Github css Cascade challenges Repo](https://github.com/HamzaMiloud/cascade-challenges).

## Let's Connect

Your comments and opinions are most welcome! Feel free to let me know whether you have any views on this article, find an inaccuracy, or a better way of doing something- let me know! You can reach me on Twitter [@HamzaMiloudAma1](https://x.com/HamzaMiloudAma1), and let's continue from there!.
